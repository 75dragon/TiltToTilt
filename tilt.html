<!DOCTYPE html>
<html>
<head>
    <title>Tilt</title>
</head>
<body>
    <canvas id="canvas"></canvas>
</body>
<style>
    canvas {
        margin: auto;
    }
    body {
        overflow: hidden;
    }
</style>
<script>
'use strict';
var canvas = document.getElementById("canvas"),
    ctx = canvas.getContext("2d"),
    width = window.innerWidth,
    height = window.innerHeight,
    mouseX = width/2,
    mouseY = height/2;

canvas.width = width;
canvas.height = height; 

var players = [];
var enemys = [];
var powerups = [];
var enemySpawner;
var powerupSpawner;
var timeTracker;
var gameOn = true;
var deadPlayers = [];
var deadEnemies = [];
var deadPowerups = [];
var enemysKilled = 0;
var time = 0;

//enum
const booms = {
    DISK: '0',
    PLUS: '+',
    CIRCLE: 'o',
    DIAMOND: 'dimd',
    BIG_DISK: '1'
}

function randomPowerUp() {
    let keys = Object.keys(booms);
    return booms[keys[randTo(keys.length)]];
}

canvas.addEventListener("mousemove", function (e) {
   mouseX = e.pageX;
   mouseY = e.pageY;
});


//player class
var Player = function (x, y, radius, color, hp) {
    this.x = x || 0;
    this.y = y || 0;
    this.radius = radius || 10;
    this.speed = 5;
    this.color = color || "rgb(255,0,0)";
    this.hp = hp || 10;
    this.velX = 0;
    this.velY = 0;
    this.immune = false;
    console.log("new player");
}

Player.prototype.update = function (x, y) {
    // get the target x and y
    this.targetX = x;
    this.targetY = y;

    // We need to get the distance this time around
    var tx = this.targetX - this.x,
        ty = this.targetY - this.y,
        dist = Math.sqrt(tx * tx + ty * ty);

    /*
     * we calculate a velocity for our object this time around
     * divide the target x and y by the distance and multiply it by our speed
     * this gives us a constant movement speed.
     */
    this.velX = (tx / dist) * this.speed;
    this.velY = (ty / dist) * this.speed;

    // Stop once we hit our target. This stops the jittery bouncing of the object.
    if (dist > this.radius / 2) {
        // add our velocities
        this.x += this.velX;
        this.y += this.velY;
    }
};

Player.prototype.render = function () {
    ctx.fillStyle = this.color;
    // draw our triangle with x and y being the center, and points twards mouse
    let dx = this.targetX - this.x
    let dy = this.targetY - this.y
    ctx.beginPath();
    //this line basically makes our length constant, because the distance from the mouse can vary, we cannot just blindly move twards the mouse location when drawing
    let myLength = this.radius / Math.sqrt(dx * dx + dy * dy);
    //since we have the ratio, we just multiply it by the difference of X/Y. This is the Tip of the player.
    ctx.moveTo(this.x + myLength * dx, this.y + myLength * dy );
    ctx.lineTo(this.x - myLength * dy - myLength * dx,
        this.y + myLength * dx - myLength * dy);
    ctx.stroke();
    ctx.lineTo(this.x + myLength * dy - myLength * dx,
        this.y - myLength * dx - myLength * dy);
    ctx.stroke();
    ctx.lineTo(this.x + myLength * dx, this.y + myLength * dy );
    ctx.stroke();
    ctx.closePath();
    ctx.fill();
};

//TODO: why does changing these to anonymous functions stop collisions from working?
Player.prototype.getX = function () { return this.x };
Player.prototype.getY = function () { return this.y };
Player.prototype.getRadius = function () { return this.radius };

Player.prototype.immune = function (time) {
    this.immune = true;
    var theplayer = this;
    var hurt = setTimeout(function () {
        theplayer.immune = false;
    }, time * 1000);
}

Player.prototype.takeHit = function (dmg) {
    if (!this.immune)
    {
        this.hp -= dmg;
        console.log("ouch! hp:" + this.hp)
        if ( this.hp > 0 )
        {
          this.immune(dmg * 2);
        }
    }
    if (this.hp <= 0)
    {
        deadPlayers.push(this);
    }
};
//end of player class

//return random integer in [0, 1, 2 .. i-1]
var randTo = (i) => Math.floor(Math.random() * i);

//enemy class
var Enemy = function (x, y, radius, color, speed, ai) {
    this.x = x || 0;
    this.y = y || 0;
    this.radius = radius || 10;
    this.speed = speed || 3;
    this.color = color || "rgb(0,0,255)";
    this.ai = ai;
    this.velX = 0;
    this.velY = 0;
    this.hitDestination = true;
    //console.log("new enemy");
}

Enemy.prototype.AI = function ( i ) {
    switch(i) {
        case 0: // move beween random spots
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
            if (this.hitDestination)
            {
                this.targetX = randTo(canvas.width) + 1;
                this.targetY = randTo(canvas.height) + 1;
                this.hitDestination = false;
            }
            break;
        case 7: // follow player
            this.targetX = players[0].getX();
            this.targetY = players[0].getY();
            break;

        case 8: //move to where the player's mouse is
            this.targetX = mouseX;
            this.targetY = mouseY;
            break;
        case 9: //corner the player! move to a spot near the player
            if (this.hitDestination)
            {
                this.targetX = players[0].getX() + randTo(500) - 250;
                this.targetY = players[0].getY() + randTo(500) - 250;
                this.hitDestination = false;
            }
            break;
    }

};

Enemy.prototype.update = function () {
    // get the target x and y from AI
    this.AI( this.ai );

    // We need to get the distance this time around
    var tx = this.targetX - this.x,
        ty = this.targetY - this.y,
        dist = Math.sqrt(tx * tx + ty * ty);

    /*
     * we calculate a velocity for our object this time around
     * divide the target x and y by the distance and multiply it by our speed
     * this gives us a constant movement speed.
     */
    this.velX = (tx / dist) * this.speed;
    this.velY = (ty / dist) * this.speed;

    // Stop once we hit our target. This stops the jittery bouncing.
    // Basically only move when we are not there yet
    // Also change hitDestination to true, so some AI's can use it.
    if (dist > this.radius / 2) {
        // add our velocities
        this.x += this.velX;
        this.y += this.velY;
    }
    else
    {
        this.hitDestination = true;
    }

    for (let i = 0; i < players.length; i++)
    {
        if ((players[i].getRadius() + this.radius) * (players[i].getRadius() + this.radius) >
        (players[i].getX() - this.x) * (players[i].getX() - this.x) + (players[i].getY() - this.y) * (players[i].getY() - this.y))
        {
          players[i].takeHit(1);
        }
    }
};

Enemy.prototype.render = function () { // draw our circle with x and y being the center
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.closePath();
    ctx.fill();
};

Enemy.prototype.getX = function () { return this.x; };
Enemy.prototype.getY = function () { return this.y; };
Enemy.prototype.getRadius = function () { return this.radius; };
// end of enemy class


//TODO bosses spawn per 25 enemies killed
var Boss1 = function(level) {
    this.health = 150 * level;
    this.x = x || 0;
    this.y = y || 0;
    this.radius = 25;
    this.speed = speed || 3;
    this.color = color || "rgb(255,0,0)";
    this.ai = ai;
    this.velX = 0;
    this.velY = 0;
    this.hitDestination = true;
    console.log("new boss");
}


//start of PowerUp class
var PowerUp = function(x, y, type) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.radius = 10;
    this.color = "rgb(0,0,0)";
    this.awake = false;
    this.active = false;
    console.log("new powerup");
}

PowerUp.prototype.update = function () {
    if (!this.awake && !this.active) { //didn't hit but spawned
        for (let i = 0; i < players.length; i++)
        {
            if ((players[i].getRadius() + this.radius) * (players[i].getRadius() + this.radius) >
            (players[i].getX() - this.x) * (players[i].getX() - this.x) + (players[i].getY() - this.y) * (players[i].getY() - this.y))
            {
                this.awake = true;
                console.log("power-up hit at: " + this.x + ", " + this.y);
            }
        }
    } else if (this.awake  && !this.active) { //second u hit
        this.active = true;
        if (this.type == booms.DISK) {
            //find and save direction
            let me = players[0];
            let dx = me.targetX - me.x;
            let dy = me.targetY - me.y;
            let norm = Math.sqrt(dx*dx + dy*dy);
            this.dx = dx/norm;
            this.dy = dy/norm;
        }
        let that = this;
        setTimeout(function () {
            console.log("powerup expired: " + that.type);
            if (that.type == booms.DIAMOND) {
                console.log("spawn 4 powerups");
                let delta = that.radius * 5;
                [ //offsets
                    [that.x + delta, that.y],
                    [that.x - delta, that.y],
                    [that.x, that.y + delta],
                    [that.x, that.y - delta]
                ].map((vec) => {
                    powerups[powerups.length] = new PowerUp(vec[0], vec[1], randomPowerUp());
                })
            }
            deadPowerups.push(that);
        }, 1000, this);
    } else if (this.awake  && this.active) {
        switch(this.type) {
            case booms.DISK:
                for (let i = 0; i < enemys.length; i++) //check if an enemy is a distance of 5 * radius or closer.
                {
                    if ((enemys[i].getRadius() + this.radius * 5) * (enemys[i].getRadius() + this.radius * 5) >
                    (enemys[i].getX() - this.x) * (enemys[i].getX() - this.x) + (enemys[i].getY() - this.y) * (enemys[i].getY() - this.y))
                    {
                        deadEnemies.push(enemys[i]);
                    }
                }
                //move the disk
                this.x += this.dx * 3
                this.y += this.dy * 3
                break;
            case booms.PLUS:
                for (let i = 0; i < enemys.length; i++) //check if an enemy is vertical or horizontal, basically a + with width/height of radius * 10. Nerf!
                {
                    if (Math.abs(this.y - enemys[i].getY()) < this.radius + enemys[i].getRadius() &&
                    Math.abs(this.x - enemys[i].getX()) < this.radius * 20 ||
                    Math.abs(this.x - enemys[i].getX()) < this.radius + enemys[i].getRadius() &&
                    Math.abs(this.y - enemys[i].getY()) < this.radius * 20 )
                    {
                        deadEnemies.push(enemys[i]);
                    }
                }
                break;

            case booms.CIRCLE:
                for (let i = 0; i < enemys.length; i++) //check if the enemys hits the ring of 7-8, if its inside it will live!
                {
                    if (Math.sqrt((this.y - enemys[i].getY()) * (this.y - enemys[i].getY()) + (this.x - enemys[i].getX()) *
                     (this.x - enemys[i].getX())) < this.radius * 8 + enemys[i].getRadius() &&
                     Math.sqrt((this.y - enemys[i].getY()) * (this.y - enemys[i].getY()) + (this.x - enemys[i].getX()) *
                        (this.x - enemys[i].getX())) > this.radius * 7 - enemys[i].getRadius())
                    {
                        deadEnemies.push(enemys[i]);
                    }
                }
                //expand
                this.radius += .2; //expand
                break;
            case booms.DIAMOND:
                for (let i = 0; i < enemys.length; i++) //check if the enemys hits the diamond
                {
                    var dx = enemys[i].getX() - this.x;
                    var dy = enemys[i].getY() - this.y;
                    var r = this.radius * 5 + enemys[i].getRadius();
                    if ( Math.abs(dy - dx) <= r && Math.abs (dy + dx) <= r)
                    {
                        deadEnemies.push(enemys[i]);
                    }
                }
                break;
            case booms.BIG_DISK:
                for (let i = 0; i < enemys.length; i++) //check if an enemy is a distance of 5 * radius or closer.
                {
                    if ((enemys[i].getRadius() + this.radius * 5) * (enemys[i].getRadius() + this.radius * 5) >
                    (enemys[i].getX() - this.x) * (enemys[i].getX() - this.x) + (enemys[i].getY() - this.y) * (enemys[i].getY() - this.y))
                    {
                        deadEnemies.push(enemys[i]);
                    }
                }
                this.radius += .15;
                break;
        }//switch
    }//if awake an active
};

PowerUp.prototype.render = function () {
    ctx.fillStyle  = this.color;
    let x = this.getX();
    let y = this.getY();
    let rad = this.getRadius();
    if ( !this.active ) //small black diamond to indicate a power up.
    {
        ctx.beginPath();
        ctx.moveTo(x + rad, y);
        ctx.lineTo(x, y - rad);
        ctx.stroke();
        ctx.lineTo(x - rad, y);
        ctx.stroke();
        ctx.lineTo(x, y + rad);
        ctx.stroke();
        ctx.lineTo(x + rad, y);
        ctx.stroke();
        ctx.closePath();
        ctx.fill();
    } else switch(this.type) {
        case booms.BIG_DISK:
        case booms.DISK:  // draw our circle with x and y being the center, radius ratio of 5.
            ctx.beginPath();
            ctx.arc(x, y, rad * 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            break;
        case booms.PLUS: //draw a + with height / width radius * 40 NERF!
            let size = 40;
            ctx.fillRect(x - rad, y - rad * size/2, rad * 2, rad * size);
            ctx.fillRect(x - rad * size/2, y - rad, rad * size, 2 * rad);
            break;
        case booms.CIRCLE: //draw a ring
            let inner = 7, outer = 7.7; //inner vs outer ratios
            ctx.beginPath();
            ctx.arc(x, y, rad * outer, 0, Math.PI * 2);
            ctx.stroke();
            ctx.lineTo(x + rad * inner, y);
            ctx.stroke();
            ctx.arc(x, y, rad * inner, 0 , Math.PI * 2, true);
            ctx.stroke();
            ctx.lineTo(x + rad * outer, y);
            ctx.stroke();
            ctx.closePath();
            ctx.fill();
            break;
        case booms.DIAMOND: // diamond
            ctx.beginPath()
            ctx.moveTo(x - rad * 5, y); 
            ctx.lineTo(x , y - rad * 5);
            ctx.stroke();
            ctx.lineTo(x + rad * 5, y);
            ctx.stroke();
            ctx.lineTo(x , y + rad * 5);
            ctx.stroke();
            ctx.lineTo(x - rad * 5, y);
            ctx.stroke();
            ctx.closePath();
            ctx.fill();
          break;
    }
};

PowerUp.prototype.getY = function () { return this.y; }
PowerUp.prototype.getX = function () { return this.x; }
PowerUp.prototype.getRadius = function () { return this.radius; }

function removeEnemy(dead) {
    enemys.splice(enemys.indexOf(dead), 1);
    enemysKilled++;
}

function removePlayer(dead) {
    players.splice(players.indexOf(dead), 1);
    if (players.length <= 0)
    {
        //alert('game over');
        console.log("GG");
        gameOn = false;
        clearInterval(enemySpawner);
        clearInterval(powerupSpawner);
        clearInterval(timeTracker);
    }
}

function removePowerup(dead) {
    powerups.splice(powerups.indexOf(dead), 1);
}

function world() {
    var player1 = new Player(width / 2, height / 2, 10, "rgb(0,0,0)", 1);
    players[0] = player1;

    enemySpawner = setInterval( function()
    {
        enemys[enemys.length] = new Enemy(randTo(2) * canvas.width,randTo(2) * canvas.height,10, "rgb(" + randTo(256) + "," + randTo(256) + "," + randTo(256) + ")", 2.5, randTo(10));
    }, 250);

    powerupSpawner = setInterval( function()
    {
        powerups[powerups.length] = new PowerUp(randTo(canvas.width) + 1, randTo(canvas.height) + 1, randomPowerUp());        
    }, 2000);

    timeTracker = setInterval( function()
    {
        time++;
    }, 1000);
}

function render() {
    ctx.clearRect(0, 0, width, height); //clear background

    enemys.map( (en) => {
        en.update();
        en.render();
    });

    powerups.map ((pw) => {
        pw.update();
        pw.render();
    });

    players[0].update(mouseX, mouseY);
    players[0].render();

    ctx.font = "30px Comic Sans MS";
    ctx.fillText("Score: " + enemysKilled, width - 200 , 100);
    ctx.fillText("Time: " + Math.floor(time / 60) + ":" + ("0" + Math.floor(time % 60)).slice(-2), width - 200, 150);

    while (deadPlayers.length > 0)
    {
        removePlayer(deadPlayers.pop());
        console.log("player down!");
    }

    while (deadEnemies.length > 0)
    {
        removeEnemy(deadEnemies.pop());
        console.log("enemy down!");
    }

    while (deadPowerups.length > 0)
    {
        removePowerup(deadPowerups.pop());
        console.log("powerup down!");
    }

    if (gameOn)
    {
        requestAnimationFrame(render);
    }
}

(function main()
{
    world();
    render();
})()
</script>
</html>
